import{_ as s,c as a,d as e,o as p}from"./app-DDoPRsSr.js";const t={};function o(c,n){return p(),a("div",null,[...n[0]||(n[0]=[e(`<h1 id="leetcode题解-字母与数字" tabindex="-1"><a class="header-anchor" href="#leetcode题解-字母与数字"><span>LeetCode题解：字母与数字</span></a></h1><p>题目链接：https://leetcode.cn/problems/find-longest-subarray-lcci/</p><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h2><p>这道题可以转化为一个经典的问题：在一个数组中找到和为k的最长子数组。我们只要将数组中的字母替换成1，数字替换成-1，那么原题就变成了在一个数组中找到和为0的最长子数组。</p><p>要解决这个问题，我们需要用到一个叫做“前缀和”的技巧。我们用<code>sum(i, j)</code>表示数组在区间<code>[i, j)</code>上的和（<code>sum(i, i) = 0</code>），如果令数组<code>prefix[i] = sum(0, i)</code>，那么就可以快速计算出<code>sum(i, j) = prefix[j] - prefix[i]</code>。</p><p>在一个数组中找到和为k的最长子数组，就等价于找到满足<code>j - i</code>最大的<code>i</code>和<code>j</code>，使得<code>prefix[j] - prefix[i] = k</code>。这是一个双变量的优化问题，我们可以先固定<code>j</code>，然后优化<code>i</code>，这时候就要最小化<code>i</code>，使得<code>prefix[i] = prefix[j] - k</code>。我们可以用一个哈希表来存储每个前缀和第一次出现的位置，这样就可以在O(1)的时间内找到满足条件的<code>i</code>。</p><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h2><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">def</span> <span class="token function">find_longest_array_with_sum_k</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token comment"># 计算前缀和</span></span>
<span class="line">    prefix_sum <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span></span>
<span class="line">    <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">:</span></span>
<span class="line">        prefix_sum<span class="token punctuation">.</span>append<span class="token punctuation">(</span>prefix_sum<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> i<span class="token punctuation">)</span></span>
<span class="line">    sum_dict <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment"># 存储前缀和第一次出现的位置</span></span>
<span class="line">    max_len <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line">    i_max <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line">    j_max <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line">    <span class="token comment"># 先固定j，然后优化i</span></span>
<span class="line">    <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">        n <span class="token operator">=</span> prefix_sum<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-</span> k</span>
<span class="line">        <span class="token keyword">if</span> n <span class="token keyword">in</span> sum_dict<span class="token punctuation">:</span></span>
<span class="line">            i <span class="token operator">=</span> sum_dict<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token comment"># 最小的i</span></span>
<span class="line">            <span class="token keyword">if</span> j <span class="token operator">-</span> i <span class="token operator">&gt;</span> max_len<span class="token punctuation">:</span></span>
<span class="line">                max_len <span class="token operator">=</span> j <span class="token operator">-</span> i</span>
<span class="line">                i_max <span class="token operator">=</span> i</span>
<span class="line">                j_max <span class="token operator">=</span> j</span>
<span class="line">        <span class="token keyword">if</span> prefix_sum<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token keyword">not</span> <span class="token keyword">in</span> sum_dict<span class="token punctuation">:</span></span>
<span class="line">            sum_dict<span class="token punctuation">[</span>prefix_sum<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> j</span>
<span class="line">    <span class="token keyword">return</span> i_max<span class="token punctuation">,</span> j_max</span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token keyword">def</span> <span class="token function">findLongestSubarray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> array<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> List<span class="token punctuation">[</span><span class="token builtin">str</span><span class="token punctuation">]</span><span class="token punctuation">:</span></span>
<span class="line">        arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">if</span> i<span class="token punctuation">.</span>isalpha<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> array<span class="token punctuation">]</span></span>
<span class="line">        i<span class="token punctuation">,</span> j <span class="token operator">=</span> find_longest_array_with_sum_k<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span></span>
<span class="line">        <span class="token keyword">return</span> array<span class="token punctuation">[</span>i<span class="token punctuation">:</span>j<span class="token punctuation">]</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8)])])}const l=s(t,[["render",o]]),r=JSON.parse('{"path":"/posts/leetcode-find-longest-subarray.html","title":"LeetCode题解：字母与数字","lang":"zh-CN","frontmatter":{"date":"2025-06-03T00:00:00.000Z","tag":["算法八股文","前缀和"]},"headers":[{"level":2,"title":"解题思路","slug":"解题思路","link":"#解题思路","children":[]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]}],"git":{"updatedTime":1763698804000,"contributors":[{"name":"shi0rik0","username":"shi0rik0","email":"anguuan@outlook.com","commits":1,"url":"https://github.com/shi0rik0"}],"changelog":[{"hash":"27621ea60c6645dc9e44007e7ab6fd2858c37eaf","time":1763698804000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Migrate posts"}]},"filePathRelative":"posts/leetcode-find-longest-subarray.md","excerpt":"\\n<p>题目链接：https://leetcode.cn/problems/find-longest-subarray-lcci/</p>\\n<h2>解题思路</h2>\\n<p>这道题可以转化为一个经典的问题：在一个数组中找到和为k的最长子数组。我们只要将数组中的字母替换成1，数字替换成-1，那么原题就变成了在一个数组中找到和为0的最长子数组。</p>\\n<p>要解决这个问题，我们需要用到一个叫做“前缀和”的技巧。我们用<code>sum(i, j)</code>表示数组在区间<code>[i, j)</code>上的和（<code>sum(i, i) = 0</code>），如果令数组<code>prefix[i] = sum(0, i)</code>，那么就可以快速计算出<code>sum(i, j) = prefix[j] - prefix[i]</code>。</p>"}');export{l as comp,r as data};
