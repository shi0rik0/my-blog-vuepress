import{_ as a,c,d as o,o as s}from"./app-DDoPRsSr.js";const t={};function r(i,e){return s(),c("div",null,[...e[0]||(e[0]=[o('<h1 id="关于csrf攻击及其防御" tabindex="-1"><a class="header-anchor" href="#关于csrf攻击及其防御"><span>关于CSRF攻击及其防御</span></a></h1><h2 id="什么是csrf攻击" tabindex="-1"><a class="header-anchor" href="#什么是csrf攻击"><span>什么是CSRF攻击</span></a></h2><p>CSRF 攻击是利用了浏览器的一个安全漏洞。假设用户在 a.com 上登入，浏览器获得了 cookie，接下来如果用户访问 b.com，而 b.com 访问了 a.com，则浏览器会将 cookie 附加在请求上，从而可能在用户不知情的情况下以登入权限进行了 a.com 的操作。尽管较新的浏览器修复了部分漏洞，但是由于要保持互联网的兼容性，因此并没有完全修复这个问题，并且我们不能假设用户使用的都是较新的浏览器，因此对 CSRF 攻击进行防御还是有必要的。</p><h2 id="如何防御csrf攻击" tabindex="-1"><a class="header-anchor" href="#如何防御csrf攻击"><span>如何防御CSRF攻击</span></a></h2><h3 id="浏览器发起请求的两种分类" tabindex="-1"><a class="header-anchor" href="#浏览器发起请求的两种分类"><span>浏览器发起请求的两种分类</span></a></h3><p>要防御 CSRF 攻击，首先要知道在什么情况下，访问 b.com 的时候浏览器会对 a.com 发起请求。主要有两种情况：</p><ol><li><p>浏览器内置的行为：b.com的页面中有一个<code>&lt;img&gt;</code>标签，<code>src</code>属性指向a.com，这样浏览器会向a.com发起请求，或者有一个<code>&lt;form&gt;</code>表单，<code>action</code>属性指向a.com，这样如果用户提交了表单，则浏览器会向a.com发起请求。可能还有其他情况，这里只列出了最常见的情况。</p></li><li><p>JavaScript脚本发起的请求：b.com执行了一个JavaScript脚本，脚本中向a.com发起了请求。</p></li></ol><p>对于第二种情况，这些请求会受到CORS机制的限制，而第一种情况则不会。这里我们还要补充一个概念：简单请求（Simple Request，其定义参见<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests" target="_blank" rel="noopener noreferrer">这里</a>）。简单来说，所有第一种情况下可能发出的请求都是简单请求。</p><p>然后我们还要解释一下CORS机制的一个细节：CORS 机制对于简单请求和复杂请求的处理是不同的。对于复杂请求，它会先给服务器发送一个 OPTIONS 请求，只有服务器返回一个允许的响应，浏览器才会发起真正的请求。而对于简单请求，浏览器会<strong>直接发送真正的请求</strong>，只不过如果服务器的响应没有说允许请求，那么浏览器将不会允许脚本获得响应的值。此时服务器还是收到了请求。这意味着什么呢？设想一下，如果一个 API 的功能是修改密码，那么只要服务器执行了该请求，攻击就已经成功了，这与浏览器脚本能否获得响应值无关。</p><h3 id="防御方法" tabindex="-1"><a class="header-anchor" href="#防御方法"><span>防御方法</span></a></h3><p>最简单的防御方法自然是完全不使用Cookie来认证，但是这样未免有点因噎废食。还有一种常用的方法是利用CSRF token，但是这种方法不适合于前后端分离的架构。这里我要介绍一种更简单的防御方法：添加自定义请求header。</p><p>我们只需要自定义一个请求header，例如<code>X-CSRF-TOKEN</code>，然后在服务端拒绝所有不包含这个header的请求即可（当然OPTIONS请求还是要按正常逻辑处理）。这样一来就拒绝了所有简单请求，而复杂请求只可能是由JavaScript脚本发起的，受到CORS的限制会先发送一个OPTIONS请求，这样就保证了只有同源的情况下才能发起真正的请求。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><ol><li><p>https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</p></li><li><p>https://owasp.org/www-community/attacks/csrf</p></li><li><p>https://danielw.cn/web-security-xss-csrf-cn#csrf</p></li><li><p>https://security.stackexchange.com/a/58308</p></li></ol>',14)])])}const n=a(t,[["render",r]]),p=JSON.parse('{"path":"/posts/csrf-attack.html","title":"关于CSRF攻击及其防御","lang":"zh-CN","frontmatter":{"date":"2024-10-25T00:00:00.000Z"},"headers":[{"level":2,"title":"什么是CSRF攻击","slug":"什么是csrf攻击","link":"#什么是csrf攻击","children":[]},{"level":2,"title":"如何防御CSRF攻击","slug":"如何防御csrf攻击","link":"#如何防御csrf攻击","children":[{"level":3,"title":"浏览器发起请求的两种分类","slug":"浏览器发起请求的两种分类","link":"#浏览器发起请求的两种分类","children":[]},{"level":3,"title":"防御方法","slug":"防御方法","link":"#防御方法","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"updatedTime":1763698804000,"contributors":[{"name":"shi0rik0","username":"shi0rik0","email":"anguuan@outlook.com","commits":1,"url":"https://github.com/shi0rik0"}],"changelog":[{"hash":"27621ea60c6645dc9e44007e7ab6fd2858c37eaf","time":1763698804000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Migrate posts"}]},"filePathRelative":"posts/csrf-attack.md","excerpt":"\\n<h2>什么是CSRF攻击</h2>\\n<p>CSRF 攻击是利用了浏览器的一个安全漏洞。假设用户在 a.com 上登入，浏览器获得了 cookie，接下来如果用户访问 b.com，而 b.com 访问了 a.com，则浏览器会将 cookie 附加在请求上，从而可能在用户不知情的情况下以登入权限进行了 a.com 的操作。尽管较新的浏览器修复了部分漏洞，但是由于要保持互联网的兼容性，因此并没有完全修复这个问题，并且我们不能假设用户使用的都是较新的浏览器，因此对 CSRF 攻击进行防御还是有必要的。</p>\\n<h2>如何防御CSRF攻击</h2>\\n<h3>浏览器发起请求的两种分类</h3>\\n<p>要防御 CSRF 攻击，首先要知道在什么情况下，访问 b.com 的时候浏览器会对 a.com 发起请求。主要有两种情况：</p>"}');export{n as comp,p as data};
