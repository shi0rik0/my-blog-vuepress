import{_ as n,c as a,d as e,o}from"./app-DDoPRsSr.js";const c={};function t(p,s){return o(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="python中的-subclasshook-方法" tabindex="-1"><a class="header-anchor" href="#python中的-subclasshook-方法"><span>Python中的__subclasshook__方法</span></a></h1><p>最近在查阅Python标准库<code>collections.abc</code>的源代码时，发现一个有趣的“魔法方法”<code>__subclasshook__</code>。这个方法其实是一个假的魔法方法，因为它并没有任何特殊性。如果一个类继承了<code>abc.ABC</code>，那么对这个类调用<code>issubclass</code>，或者对这个类的对象调用<code>isinstance</code>时，Python就会自动调用这个类的<code>__subclasshook__</code>方法。</p><p>举个例子，下面的类<code>Addable</code>用来描述可以进行加法运算的接口。</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">from</span> abc <span class="token keyword">import</span> ABC</span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Addable</span><span class="token punctuation">(</span>ABC<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token decorator annotation punctuation">@classmethod</span></span>
<span class="line">    <span class="token keyword">def</span> <span class="token function">__subclasshook__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> subclass<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token keyword">if</span> cls <span class="token keyword">is</span> Addable<span class="token punctuation">:</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token builtin">any</span><span class="token punctuation">(</span><span class="token string">&quot;__add__&quot;</span> <span class="token keyword">in</span> B<span class="token punctuation">.</span>__dict__ <span class="token keyword">for</span> B <span class="token keyword">in</span> subclass<span class="token punctuation">.</span>__mro__<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">                <span class="token keyword">return</span> <span class="token boolean">True</span></span>
<span class="line">        <span class="token keyword">return</span> NotImplemented</span>
<span class="line"></span>
<span class="line"><span class="token keyword">assert</span> <span class="token builtin">issubclass</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> Addable<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">assert</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Addable<span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">assert</span> <span class="token keyword">not</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span> Addable<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里有一些值得注意的地方：</p><ol><li><code>__subclasshook__</code>必须是一个class method。</li><li>在判断之前，必须先判断<code>cls</code>是否是自身。具体原因我不是很清楚，这里是照抄了官方的例子。</li><li>可以利用<code>__mro__</code>和<code>__dict__</code>来判断一个类是否实现了某个方法。这里的判断其实很粗糙，只能检测是否存在某个属性，连该属性是否可调用都没有判断，更别说参数和返回值类型了。不过官方的例子也没有做这些检查。</li><li>如果发现不符合接口要求，应该返回<code>NotImplemented</code>，而不是<code>False</code>。这里的<code>NotImplemented</code>是Python内置的一个特殊常量，不要和<code>NotImplementedError</code>搞混了。</li></ol>`,6)])])}const i=n(c,[["render",t]]),d=JSON.parse('{"path":"/posts/python-subclasshook.html","title":"Python中的__subclasshook__方法","lang":"zh-CN","frontmatter":{"date":"2025-05-13T00:00:00.000Z"},"headers":[],"git":{"updatedTime":1763698804000,"contributors":[{"name":"shi0rik0","username":"shi0rik0","email":"anguuan@outlook.com","commits":1,"url":"https://github.com/shi0rik0"}],"changelog":[{"hash":"27621ea60c6645dc9e44007e7ab6fd2858c37eaf","time":1763698804000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Migrate posts"}]},"filePathRelative":"posts/python-subclasshook.md","excerpt":"\\n<p>最近在查阅Python标准库<code>collections.abc</code>的源代码时，发现一个有趣的“魔法方法”<code>__subclasshook__</code>。这个方法其实是一个假的魔法方法，因为它并没有任何特殊性。如果一个类继承了<code>abc.ABC</code>，那么对这个类调用<code>issubclass</code>，或者对这个类的对象调用<code>isinstance</code>时，Python就会自动调用这个类的<code>__subclasshook__</code>方法。</p>\\n<p>举个例子，下面的类<code>Addable</code>用来描述可以进行加法运算的接口。</p>"}');export{i as comp,d as data};
