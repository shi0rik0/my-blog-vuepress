import{_ as n,c as a,d as e,o as l}from"./app-DEX1Ewll.js";const t={};function p(o,s){return l(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="leetcode题解-环路检测" tabindex="-1"><a class="header-anchor" href="#leetcode题解-环路检测"><span>LeetCode题解：环路检测</span></a></h1><p>原题网址：https://leetcode.cn/problems/linked-list-cycle-lcci/</p><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h2><p>这道题目就是经典的<a href="https://en.wikipedia.org/wiki/Cycle_detection#Floyd&#39;s_tortoise_and_hare" target="_blank" rel="noopener noreferrer">Floyd龟兔赛跑算法</a>。这个算法主要分为两个部分，第一个部分就是如何判定是否有环，第二个部分就是如何找到环的起点。第一个部分比较简单，很容易理解，因此也很脍炙人口。但是第二个部分就比较少人知道了，因为其推导过程相对复杂一些，具体可以参考<a href="https://leetcode.cn/problems/linked-list-cycle-lcci/solutions/531787/huan-lu-jian-ce-by-leetcode-solution-s2la/" target="_blank" rel="noopener noreferrer">LeetCode官方的题解</a>。</p><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h2><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token comment"># Definition for singly-linked list.</span></span>
<span class="line"><span class="token comment"># class ListNode:</span></span>
<span class="line"><span class="token comment">#     def __init__(self, x):</span></span>
<span class="line"><span class="token comment">#         self.val = x</span></span>
<span class="line"><span class="token comment">#         self.next = None</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token keyword">def</span> <span class="token function">detectCycle</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> head<span class="token punctuation">:</span> ListNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> ListNode<span class="token punctuation">:</span></span>
<span class="line">        <span class="token keyword">if</span> head <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token boolean">None</span></span>
<span class="line">        slow <span class="token operator">=</span> head<span class="token punctuation">.</span><span class="token builtin">next</span></span>
<span class="line">        <span class="token keyword">if</span> slow <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token boolean">None</span></span>
<span class="line">        fast <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span></span>
<span class="line">        <span class="token keyword">if</span> fast <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span></span>
<span class="line">            <span class="token keyword">return</span> <span class="token boolean">None</span></span>
<span class="line">        <span class="token keyword">while</span> slow <span class="token keyword">is</span> <span class="token keyword">not</span> fast<span class="token punctuation">:</span></span>
<span class="line">            <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">                fast <span class="token operator">=</span> fast<span class="token punctuation">.</span><span class="token builtin">next</span></span>
<span class="line">                <span class="token keyword">if</span> fast <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span></span>
<span class="line">                    <span class="token keyword">return</span> <span class="token boolean">None</span></span>
<span class="line">            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span></span>
<span class="line">        third <span class="token operator">=</span> head</span>
<span class="line">        <span class="token keyword">while</span> third <span class="token keyword">is</span> <span class="token keyword">not</span> slow<span class="token punctuation">:</span></span>
<span class="line">            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span><span class="token builtin">next</span></span>
<span class="line">            third <span class="token operator">=</span> third<span class="token punctuation">.</span><span class="token builtin">next</span></span>
<span class="line">        <span class="token keyword">return</span> slow</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6)])])}const c=n(t,[["render",p]]),r=JSON.parse(`{"path":"/posts/2025/05/leetcode-linked-list-cycle.html","title":"LeetCode题解：环路检测","lang":"zh-CN","frontmatter":{"date":"2025-05-30T00:00:00.000Z","tag":["算法八股文"]},"headers":[{"level":2,"title":"解题思路","slug":"解题思路","link":"#解题思路","children":[]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]}],"git":{"updatedTime":1763699399000,"contributors":[{"name":"shi0rik0","username":"shi0rik0","email":"anguuan@outlook.com","commits":2,"url":"https://github.com/shi0rik0"}],"changelog":[{"hash":"35d50711ef3a591a2383977aa02873c707aa5c1e","time":1763699399000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Organize files by date"},{"hash":"27621ea60c6645dc9e44007e7ab6fd2858c37eaf","time":1763698804000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Migrate posts"}]},"filePathRelative":"posts/2025/05/leetcode-linked-list-cycle.md","excerpt":"\\n<p>原题网址：https://leetcode.cn/problems/linked-list-cycle-lcci/</p>\\n<h2>解题思路</h2>\\n<p>这道题目就是经典的<a href=\\"https://en.wikipedia.org/wiki/Cycle_detection#Floyd's_tortoise_and_hare\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Floyd龟兔赛跑算法</a>。这个算法主要分为两个部分，第一个部分就是如何判定是否有环，第二个部分就是如何找到环的起点。第一个部分比较简单，很容易理解，因此也很脍炙人口。但是第二个部分就比较少人知道了，因为其推导过程相对复杂一些，具体可以参考<a href=\\"https://leetcode.cn/problems/linked-list-cycle-lcci/solutions/531787/huan-lu-jian-ce-by-leetcode-solution-s2la/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">LeetCode官方的题解</a>。</p>"}`);export{c as comp,r as data};
