import{_ as o,c,d as s,o as n}from"./app-DDoPRsSr.js";const a={};function r(d,e){return n(),c("div",null,[...e[0]||(e[0]=[s(`<h1 id="关于docker的当前目录" tabindex="-1"><a class="header-anchor" href="#关于docker的当前目录"><span>关于Docker的当前目录</span></a></h1><p>最近被 Docker 的当前目录位置整得有些混乱，特地在此整理一下。</p><h2 id="docker-build" tabindex="-1"><a class="header-anchor" href="#docker-build"><span>Docker Build</span></a></h2><p>执行<code>docker build</code>命令的时候，需要传入一个 positional 参数，这个参数就是 context。举个例子，假如当前 shell 的目录是<code>/root</code>，我们执行以下命令：</p><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code><span class="line"><span class="token function">docker</span> build <span class="token parameter variable">-f</span> dockerfiles/a.Dockerfile dockerfiles</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>那么，构建过程中 Dockerfile 的 context 就是<code>/root/dockerfiles</code>。Context 的值会有以下三个影响：</p><ol><li>Context 的值就是 Dockerfile 中<code>.</code>所代表的目录。</li><li>Docker 会将 context 目录下的所有文件（除了被.dockerignore 排除的）复制一遍。在构建镜像的时候，<code>COPY</code>命令只能访问到 context 下的文件。<strong>这里有一个坑点</strong>：假如我们将 context 设置成/root，那么在 Dockerfile 中访问<code>../tmp/a.txt</code>的时候不会立刻报错，而是会访问<code>/root/tmp/a.txt</code>。</li><li>Docker 在查找全局的.dockerignore 的时候，也是会在 context 目录下查找。但是这里又有一个坑点：Docker 还支持针对某个特定 Dockerfile 的.dockerignore，假设 Dockerfile 文件名为<code>foo.Dockerfile</code>，那么对应的.dockerignore 文件名就是<code>foo.Dockerfile.dockerignore</code>，但是这种.dockerignore 是在 Dockerfile 文件所在的目录下查找，而非 context 目录。举例来说，假如 Dockerfile 是<code>/root/dockerfiles/a.Dockerfile</code>，context 设置为<code>/root</code>，那么生效的.dockerignore 路径就是<code>/root/.dockerignore</code>以及<code>/root/dockerfiles/a.Dockerfile.dockerignore</code>。</li></ol><h2 id="docker-compose" tabindex="-1"><a class="header-anchor" href="#docker-compose"><span>Docker Compose</span></a></h2><p>Docker Compose 的当前目录是<code>docker-compose.yml</code>配置文件所在的目录，而<strong>不是</strong>执行<code>docker compose</code>命令时 shell 的当前目录，并且没有选项可以更改它。</p><p>但是这里又有一个坑点：在 Docker Compose 的配置文件中可以指定从本地的 Dockerfile 构建镜像，例如：</p><div class="language-yaml line-numbers-mode" data-highlighter="prismjs" data-ext="yml"><pre><code><span class="line"><span class="token key atrule">services</span><span class="token punctuation">:</span></span>
<span class="line">  <span class="token key atrule">service-0</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token key atrule">build</span><span class="token punctuation">:</span></span>
<span class="line">      <span class="token key atrule">context</span><span class="token punctuation">:</span> ..</span>
<span class="line">      <span class="token key atrule">dockerfile</span><span class="token punctuation">:</span> docker/Dockerfile</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里面的<code>context</code>选项是相对于<code>docker-compose.yml</code>所在目录的，但是<code>dockerfile</code>选项却是相对于<code>context</code>的。也就是说，假如上面的配置文件位于<code>/foo/docker-compose.yml</code>，那么<code>context</code>就是<code>/</code>，而 Dockerfile 应该位于<code>/docker/Dockerfile</code>。</p>`,12)])])}const l=o(a,[["render",r]]),t=JSON.parse('{"path":"/posts/docker-current-dir.html","title":"关于Docker的当前目录","lang":"zh-CN","frontmatter":{"date":"2024-09-20T00:00:00.000Z"},"headers":[{"level":2,"title":"Docker Build","slug":"docker-build","link":"#docker-build","children":[]},{"level":2,"title":"Docker Compose","slug":"docker-compose","link":"#docker-compose","children":[]}],"git":{"updatedTime":1763698804000,"contributors":[{"name":"shi0rik0","username":"shi0rik0","email":"anguuan@outlook.com","commits":1,"url":"https://github.com/shi0rik0"}],"changelog":[{"hash":"27621ea60c6645dc9e44007e7ab6fd2858c37eaf","time":1763698804000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Migrate posts"}]},"filePathRelative":"posts/docker-current-dir.md","excerpt":"\\n<p>最近被 Docker 的当前目录位置整得有些混乱，特地在此整理一下。</p>\\n<h2>Docker Build</h2>\\n<p>执行<code>docker build</code>命令的时候，需要传入一个 positional 参数，这个参数就是 context。举个例子，假如当前 shell 的目录是<code>/root</code>，我们执行以下命令：</p>\\n<div class=\\"language-bash line-numbers-mode\\" data-highlighter=\\"prismjs\\" data-ext=\\"sh\\"><pre><code><span class=\\"line\\"><span class=\\"token function\\">docker</span> build <span class=\\"token parameter variable\\">-f</span> dockerfiles/a.Dockerfile dockerfiles</span>\\n<span class=\\"line\\"></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{l as comp,t as data};
