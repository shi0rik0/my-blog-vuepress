import{_ as a,c as s,d as e,o as t}from"./app-DDoPRsSr.js";const o={};function l(p,n){return t(),s("div",null,[...n[0]||(n[0]=[e(`<h1 id="在electron中读取并显示本地图片" tabindex="-1"><a class="header-anchor" href="#在electron中读取并显示本地图片"><span>在Electron中读取并显示本地图片</span></a></h1><p>最近需要在Electron应用程序中实现读取并显示本地图片的功能。这个功能看起来简单，但实现起来还是会遇到很多坑。这里就总结一下我遇到的问题，并给出一个完整的解决方案。</p><h2 id="两种方案" tabindex="-1"><a class="header-anchor" href="#两种方案"><span>两种方案</span></a></h2><p>首先，Electron是不支持在渲染进程中直接读取本地文件的，所以必须要通过主进程来读取文件。这里有两种方案：</p><ol><li>利用Electron的<a href="https://www.electronjs.org/docs/latest/api/protocol" target="_blank" rel="noopener noreferrer">Protocol API</a>，将本地文件映射到一个自定义的协议，然后在渲染进程中通过这个协议来读取文件。</li><li>直接在主进程中提供一个读取文件的接口，然后在渲染进程中调用这个接口来读取文件。</li></ol><p>第一种方案看起来更优雅，因为这样就可以直接通过修改img标签的src属性来显示图片，但实际上这种方案会导致一个问题：修改src属性之后图片不会自动刷新，所以最终我放弃了这种方案。</p><h2 id="序列化问题" tabindex="-1"><a class="header-anchor" href="#序列化问题"><span>序列化问题</span></a></h2><p>如果采用第二种方案，就会遇到一个问题：如何在主进程和渲染进程之间传递文件数据。最直接的方法是将文件数据序列化为Base64字符串，但是这样势必会降低性能，所以我希望能够直接传递二进制数据。但是Electron的序列化机制似乎无法正确传递Buffer对象，所以要将Buffer对象转换为Uint8Array对象。</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line">ipcMain<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token string">&#39;load-file&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">const</span> content <span class="token operator">=</span> <span class="token keyword">await</span> fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token punctuation">{</span> encoding<span class="token operator">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token keyword">return</span> Uint8Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="让img标签显示图片" tabindex="-1"><a class="header-anchor" href="#让img标签显示图片"><span>让img标签显示图片</span></a></h2><p>最后的问题就是如何让img标签显示二进制数据的图片。一种简单的办法是将二进制数据转换为Base64字符串，然后将这个字符串赋值给img标签的src属性，比如说<code>&lt;img src=&quot;data:image/png;base64,{base64_str}&quot;&gt;</code>。但这里又有个麻烦的地方：我们必须指定图片的MIME类型。当然我们可以通过图片扩展名或者元数据来判断图片类型，但是我嫌麻烦，所以后来发现一个更简单的方法，直接指定MIME类型为<code>image/unknown</code>，这样浏览器会自动识别图片类型（当然这不是符合标准的）。</p>`,11)])])}const i=a(o,[["render",l]]),r=JSON.parse('{"path":"/posts/electron-read-images.html","title":"在Electron中读取并显示本地图片","lang":"zh-CN","frontmatter":{"date":"2025-02-12T00:00:00.000Z","tag":["electron"]},"headers":[{"level":2,"title":"两种方案","slug":"两种方案","link":"#两种方案","children":[]},{"level":2,"title":"序列化问题","slug":"序列化问题","link":"#序列化问题","children":[]},{"level":2,"title":"让img标签显示图片","slug":"让img标签显示图片","link":"#让img标签显示图片","children":[]}],"git":{"updatedTime":1763698804000,"contributors":[{"name":"shi0rik0","username":"shi0rik0","email":"anguuan@outlook.com","commits":1,"url":"https://github.com/shi0rik0"}],"changelog":[{"hash":"27621ea60c6645dc9e44007e7ab6fd2858c37eaf","time":1763698804000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Migrate posts"}]},"filePathRelative":"posts/electron-read-images.md","excerpt":"\\n<p>最近需要在Electron应用程序中实现读取并显示本地图片的功能。这个功能看起来简单，但实现起来还是会遇到很多坑。这里就总结一下我遇到的问题，并给出一个完整的解决方案。</p>\\n<h2>两种方案</h2>\\n<p>首先，Electron是不支持在渲染进程中直接读取本地文件的，所以必须要通过主进程来读取文件。这里有两种方案：</p>\\n<ol>\\n<li>利用Electron的<a href=\\"https://www.electronjs.org/docs/latest/api/protocol\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Protocol API</a>，将本地文件映射到一个自定义的协议，然后在渲染进程中通过这个协议来读取文件。</li>\\n<li>直接在主进程中提供一个读取文件的接口，然后在渲染进程中调用这个接口来读取文件。</li>\\n</ol>"}');export{i as comp,r as data};
