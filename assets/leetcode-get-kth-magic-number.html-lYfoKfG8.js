import{_ as a,c as s,d as e,o as p}from"./app-DEX1Ewll.js";const t={};function c(l,n){return p(),s("div",null,[...n[0]||(n[0]=[e(`<h1 id="leetcode题解-第k个数" tabindex="-1"><a class="header-anchor" href="#leetcode题解-第k个数"><span>LeetCode题解：第k个数</span></a></h1><p>题目链接：https://leetcode.cn/problems/get-kth-magic-number-lcci/</p><h2 id="解题思路" tabindex="-1"><a class="header-anchor" href="#解题思路"><span>解题思路</span></a></h2><p>这道题有时间复杂度为O(k)的解法，但是这里介绍一个更通用且更容易理解的算法，其时间复杂度为O(k log k)。</p><p>给出集合\${f(a, b, c) | a, b, c \\in \\mathbb{N}^+}$，其中$f(a, b, c) = 3^a \\cdot 5^b \\cdot 7^c$。我们需要找到这个集合中的第k个最小值。注意到$f(a, b, c)$是单调递增的，也就是说如果$a_1 \\leq a_2$，$b_1 \\leq b_2$，$c_1 \\leq c_2$，那么$f(a_1, b_1, c_1) \\leq f(a_2, b_2, c_2)$。因此，假如我们把这个问题看作一个按照大小顺序进行搜索的问题，那么下一个要搜索的(a, b, c)一定会和已搜索过的(a, b, c)相邻，所以我们只需要用一个优先队列来存储已搜索过的(a, b, c)的邻居，从中获取下一个要搜索的(a, b, c)即可。我们还需要一个哈希表来记录已搜索过的(a, b, c)，以避免重复搜索。</p><h2 id="代码实现" tabindex="-1"><a class="header-anchor" href="#代码实现"><span>代码实现</span></a></h2><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">import</span> heapq</span>
<span class="line"></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token keyword">def</span> <span class="token function">getKthMagicNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">int</span><span class="token punctuation">:</span></span>
<span class="line">        seen <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">        queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></span>
<span class="line">        i <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line">        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span></span>
<span class="line">            n <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>queue<span class="token punctuation">)</span></span>
<span class="line">            <span class="token keyword">if</span> n <span class="token keyword">in</span> seen<span class="token punctuation">:</span></span>
<span class="line">                <span class="token keyword">continue</span></span>
<span class="line">            seen<span class="token punctuation">.</span>add<span class="token punctuation">(</span>n<span class="token punctuation">)</span></span>
<span class="line">            i <span class="token operator">+=</span> <span class="token number">1</span></span>
<span class="line">            <span class="token keyword">if</span> i <span class="token operator">==</span> k<span class="token punctuation">:</span></span>
<span class="line">                <span class="token keyword">return</span> n</span>
<span class="line">            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>queue<span class="token punctuation">,</span> n <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span></span>
<span class="line">            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>queue<span class="token punctuation">,</span> n <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span></span>
<span class="line">            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>queue<span class="token punctuation">,</span> n <span class="token operator">*</span> <span class="token number">7</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7)])])}const i=a(t,[["render",c]]),u=JSON.parse('{"path":"/posts/2025/06/leetcode-get-kth-magic-number.html","title":"LeetCode题解：第k个数","lang":"zh-CN","frontmatter":{"date":"2025-06-04T00:00:00.000Z","tag":["算法八股文"]},"headers":[{"level":2,"title":"解题思路","slug":"解题思路","link":"#解题思路","children":[]},{"level":2,"title":"代码实现","slug":"代码实现","link":"#代码实现","children":[]}],"git":{"updatedTime":1763699399000,"contributors":[{"name":"shi0rik0","username":"shi0rik0","email":"anguuan@outlook.com","commits":2,"url":"https://github.com/shi0rik0"}],"changelog":[{"hash":"35d50711ef3a591a2383977aa02873c707aa5c1e","time":1763699399000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Organize files by date"},{"hash":"27621ea60c6645dc9e44007e7ab6fd2858c37eaf","time":1763698804000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Migrate posts"}]},"filePathRelative":"posts/2025/06/leetcode-get-kth-magic-number.md","excerpt":"\\n<p>题目链接：https://leetcode.cn/problems/get-kth-magic-number-lcci/</p>\\n<h2>解题思路</h2>\\n<p>这道题有时间复杂度为O(k)的解法，但是这里介绍一个更通用且更容易理解的算法，其时间复杂度为O(k log k)。</p>\\n<p>给出集合${f(a, b, c) | a, b, c \\\\in \\\\mathbb{N}^+}$，其中$f(a, b, c) = 3^a \\\\cdot 5^b \\\\cdot 7^c$。我们需要找到这个集合中的第k个最小值。注意到$f(a, b, c)$是单调递增的，也就是说如果$a_1 \\\\leq a_2$，$b_1 \\\\leq b_2$，$c_1 \\\\leq c_2$，那么$f(a_1, b_1, c_1) \\\\leq f(a_2, b_2, c_2)$。因此，假如我们把这个问题看作一个按照大小顺序进行搜索的问题，那么下一个要搜索的(a, b, c)一定会和已搜索过的(a, b, c)相邻，所以我们只需要用一个优先队列来存储已搜索过的(a, b, c)的邻居，从中获取下一个要搜索的(a, b, c)即可。我们还需要一个哈希表来记录已搜索过的(a, b, c)，以避免重复搜索。</p>"}');export{i as comp,u as data};
