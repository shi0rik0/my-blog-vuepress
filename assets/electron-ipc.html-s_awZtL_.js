import{_ as s,c as a,d as e,o as p}from"./app-D9VVartN.js";const t={};function c(o,n){return p(),a("div",null,[...n[0]||(n[0]=[e(`<h1 id="electron-ipc教程" tabindex="-1"><a class="header-anchor" href="#electron-ipc教程"><span>Electron IPC教程</span></a></h1><h2 id="electron的进程模型" tabindex="-1"><a class="header-anchor" href="#electron的进程模型"><span>Electron的进程模型</span></a></h2><p>在Electron中，有两种进程：主进程和渲染进程。渲染进程本质上就是一个Chromium的进程，它只负责渲染页面，不能访问Node.js提供的操作系统相关的API。主进程是Node.js的进程，可以访问操作系统的API。主进程和渲染进程之间通过IPC（Inter-Process Communication）进行通信。</p><p>这种模型的好处就在于：</p><ol><li>不需要大幅修改Chromium的源码。</li><li>保证了浏览器环境的安全性。</li></ol><h2 id="如何使用ipc" tabindex="-1"><a class="header-anchor" href="#如何使用ipc"><span>如何使用IPC</span></a></h2><p>假设我们希望在渲染进程中读取本地文件。</p><p>首先在主进程的入口<code>main.ts</code>中创建一个接口<code>read-file</code>：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> app<span class="token punctuation">,</span> BrowserWindow<span class="token punctuation">,</span> ipcMain <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;electron&#39;</span></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> promises <span class="token keyword">as</span> fs <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;fs&#39;</span></span>
<span class="line"></span>
<span class="line">app<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;ready&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  ipcMain<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token string">&#39;read-file&#39;</span><span class="token punctuation">,</span> <span class="token keyword">async</span> <span class="token punctuation">(</span>event<span class="token punctuation">,</span> filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">await</span> fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> <span class="token string">&#39;utf-8&#39;</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">  <span class="token function">createWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里要注意，不能在<code>createWindow</code>函数中注册API，因为<code>createWindow</code>函数可能会被调用多次。</p><p>然后在<code>preload.ts</code>中将<code>read-file</code>接口暴露给渲染进程：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> contextBridge<span class="token punctuation">,</span> ipcRenderer <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;electron&#39;</span></span>
<span class="line"></span>
<span class="line">contextBridge<span class="token punctuation">.</span><span class="token function">exposeInMainWorld</span><span class="token punctuation">(</span><span class="token string">&#39;eAPI&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function-variable function">readFile</span><span class="token operator">:</span> <span class="token punctuation">(</span>filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> ipcRenderer<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token string">&#39;read-file&#39;</span><span class="token punctuation">,</span> filePath<span class="token punctuation">)</span><span class="token punctuation">,</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（<code>preload.ts</code>是渲染进程在正式运行前执行的一个脚本，它具有更多的权限。这个设计主要是为了保证运行时的安全。）</p><p>这样就可以在渲染进程中通过<code>window.eAPI.readFile()</code>来调用主进程的<code>read-file</code>接口了。例如在Vue组件中：</p><div class="language-vue line-numbers-mode" data-highlighter="prismjs" data-ext="vue"><pre><code><span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">setup</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>ts<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript"></span>
<span class="line"><span class="token keyword">import</span> <span class="token punctuation">{</span> ref <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> content <span class="token operator">=</span> ref<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token keyword">const</span> <span class="token function-variable function">readFile</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  content<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">await</span> window<span class="token punctuation">.</span>eAPI<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">&#39;path/to/file&#39;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>readFile<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Read File<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span></span>
<span class="line">  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{ content }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="typescript支持" tabindex="-1"><a class="header-anchor" href="#typescript支持"><span>TypeScript支持</span></a></h2><p>Electron无法自动推导出IPC接口的类型，只能手动定义。在项目的任意位置创建一个<code>.d.ts</code>文件，例如<code>src/window.d.ts</code>，然后定义接口：</p><div class="language-typescript line-numbers-mode" data-highlighter="prismjs" data-ext="ts"><pre><code><span class="line"><span class="token keyword">interface</span> <span class="token class-name"><span class="token constant">API</span></span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function-variable function">readFile</span><span class="token operator">:</span> <span class="token punctuation">(</span>filePath<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">declare</span> global <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span></span>
<span class="line">    eAPI<span class="token operator">:</span> <span class="token constant">API</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样TypeScript就能正确推导出<code>window.eAPI.readFile()</code>的类型了。</p>`,19)])])}const i=s(t,[["render",c]]),u=JSON.parse('{"path":"/posts/2025/02/electron-ipc.html","title":"Electron IPC教程","lang":"zh-CN","frontmatter":{"date":"2025-02-10T00:00:00.000Z","tag":["electron"]},"headers":[{"level":2,"title":"Electron的进程模型","slug":"electron的进程模型","link":"#electron的进程模型","children":[]},{"level":2,"title":"如何使用IPC","slug":"如何使用ipc","link":"#如何使用ipc","children":[]},{"level":2,"title":"TypeScript支持","slug":"typescript支持","link":"#typescript支持","children":[]}],"git":{"updatedTime":1763699399000,"contributors":[{"name":"shi0rik0","username":"shi0rik0","email":"anguuan@outlook.com","commits":2,"url":"https://github.com/shi0rik0"}],"changelog":[{"hash":"35d50711ef3a591a2383977aa02873c707aa5c1e","time":1763699399000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Organize files by date"},{"hash":"27621ea60c6645dc9e44007e7ab6fd2858c37eaf","time":1763698804000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Migrate posts"}]},"filePathRelative":"posts/2025/02/electron-ipc.md","excerpt":"\\n<h2>Electron的进程模型</h2>\\n<p>在Electron中，有两种进程：主进程和渲染进程。渲染进程本质上就是一个Chromium的进程，它只负责渲染页面，不能访问Node.js提供的操作系统相关的API。主进程是Node.js的进程，可以访问操作系统的API。主进程和渲染进程之间通过IPC（Inter-Process Communication）进行通信。</p>\\n<p>这种模型的好处就在于：</p>\\n<ol>\\n<li>不需要大幅修改Chromium的源码。</li>\\n<li>保证了浏览器环境的安全性。</li>\\n</ol>\\n<h2>如何使用IPC</h2>\\n<p>假设我们希望在渲染进程中读取本地文件。</p>"}');export{i as comp,u as data};
