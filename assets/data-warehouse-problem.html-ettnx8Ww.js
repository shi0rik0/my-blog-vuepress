import{_ as s,c as n,d as e,o as t}from"./app-D9VVartN.js";const p={};function i(l,a){return t(),n("div",null,[...a[0]||(a[0]=[e(`<h1 id="关于在data-warehouse中实例化view的优化问题" tabindex="-1"><a class="header-anchor" href="#关于在data-warehouse中实例化view的优化问题"><span>关于在data warehouse中实例化view的优化问题</span></a></h1><h2 id="问题背景" tabindex="-1"><a class="header-anchor" href="#问题背景"><span>问题背景</span></a></h2><p>假设我们有一个名为 SalesTable 的 SQL 表格，这个表格有 4 列：time_、kind、shop 和 sales，分别代表某个时间段内某个种类的商品在某家商店的销售额。</p><p>假如我们需要统计每个时间段内每个种类商品的销售总额，那么我们可以这么编写 SQL 语句：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> time_<span class="token punctuation">,</span> kind<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>sales<span class="token punctuation">)</span> <span class="token keyword">FROM</span> SalesTable <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> time_<span class="token punctuation">,</span> kind<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们不妨将这个查询结果记作 TK。</p><p>假如我们还需要统计每个种类商品的销售总额，那么我们可以这么编写 SQL 语句：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> kind<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>sales<span class="token punctuation">)</span> <span class="token keyword">FROM</span> SalesTable <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> kind<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>我们将这个查询结果记作 K。要想得到 K，还有另外一种方法，就是利用前面的 TK：</p><div class="language-sql line-numbers-mode" data-highlighter="prismjs" data-ext="sql"><pre><code><span class="line"><span class="token keyword">SELECT</span> kind<span class="token punctuation">,</span> <span class="token function">SUM</span><span class="token punctuation">(</span>sales<span class="token punctuation">)</span> <span class="token keyword">FROM</span> TK <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> kind<span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>假如我们将 TK 的结果实例化（materialize，也就是缓存），那么就可以减少查询 K 的开销，因为 TK 的行数显然比 SalesTable 少得多。</p><h2 id="问题定义" tabindex="-1"><a class="header-anchor" href="#问题定义"><span>问题定义</span></a></h2><p>给定一个有向图$(G,E)$，图中的每个节点代表一个表格或者 view，如果节点$B$可以由节点$A$得到，就建立一条边$A \\to B$。我们可以实例化一些节点，把实例化的节点集合记作$M$。把一个节点的“邻居”和它自身记作$N(V)$，也就是说，$N(V)=\\{V\\} \\cup \\{W| W \\to V \\in E\\}$。把一个节点的行数（数据规模）记作$S(V)$。一个节点的查询代价定义为</p><p>$$ C(V) = \\min_{W\\in N(V) \\cap M} S(W) $$</p><p>现在的问题是，我们已经实例化了一些节点（通常是根表格，比如说上面例子中的 SalesTable），我们希望再实例化$K$个节点（$K$是一个常数），使得总查询代价$C=\\sum_{V\\in G}C(V)$能够减少最多。我们将这个问题的结果定义为这个<strong>减少量</strong>。</p><h2 id="贪心算法" tabindex="-1"><a class="header-anchor" href="#贪心算法"><span>贪心算法</span></a></h2><p>我们可以采用贪心算法解决这个问题，也就是说，我们依次选取节点加入$M$中，每次都选取一个能使$C$减少最多的节点。</p><p>Gupta [1] 证明了这么一个结论：贪心算法的近似比是$1-\\frac{1}{e} \\approx 0.63$。也就是说，贪心算法得到的结果至少是最优结果的 0.63 倍。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h2><p>[1] Gupta, H. (1997). Selection of views to materialize in a data warehouse. In Database Theory—ICDT&#39;97: 6th International Conference Delphi, Greece, January 8–10, 1997 Proceedings 6 (pp. 98-112). Springer Berlin Heidelberg.</p>`,20)])])}const c=s(p,[["render",i]]),r=JSON.parse('{"path":"/posts/2024/07/data-warehouse-problem.html","title":"关于在data warehouse中实例化view的优化问题","lang":"zh-CN","frontmatter":{"date":"2024-07-14T00:00:00.000Z"},"headers":[{"level":2,"title":"问题背景","slug":"问题背景","link":"#问题背景","children":[]},{"level":2,"title":"问题定义","slug":"问题定义","link":"#问题定义","children":[]},{"level":2,"title":"贪心算法","slug":"贪心算法","link":"#贪心算法","children":[]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"updatedTime":1763699399000,"contributors":[{"name":"shi0rik0","username":"shi0rik0","email":"anguuan@outlook.com","commits":2,"url":"https://github.com/shi0rik0"}],"changelog":[{"hash":"35d50711ef3a591a2383977aa02873c707aa5c1e","time":1763699399000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Organize files by date"},{"hash":"27621ea60c6645dc9e44007e7ab6fd2858c37eaf","time":1763698804000,"email":"anguuan@outlook.com","author":"shi0rik0","message":"Migrate posts"}]},"filePathRelative":"posts/2024/07/data-warehouse-problem.md","excerpt":"\\n<h2>问题背景</h2>\\n<p>假设我们有一个名为 SalesTable 的 SQL 表格，这个表格有 4 列：time_、kind、shop 和 sales，分别代表某个时间段内某个种类的商品在某家商店的销售额。</p>\\n<p>假如我们需要统计每个时间段内每个种类商品的销售总额，那么我们可以这么编写 SQL 语句：</p>\\n<div class=\\"language-sql line-numbers-mode\\" data-highlighter=\\"prismjs\\" data-ext=\\"sql\\"><pre><code><span class=\\"line\\"><span class=\\"token keyword\\">SELECT</span> time_<span class=\\"token punctuation\\">,</span> kind<span class=\\"token punctuation\\">,</span> <span class=\\"token function\\">SUM</span><span class=\\"token punctuation\\">(</span>sales<span class=\\"token punctuation\\">)</span> <span class=\\"token keyword\\">FROM</span> SalesTable <span class=\\"token keyword\\">GROUP</span> <span class=\\"token keyword\\">BY</span> time_<span class=\\"token punctuation\\">,</span> kind<span class=\\"token punctuation\\">;</span></span>\\n<span class=\\"line\\"></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{c as comp,r as data};
